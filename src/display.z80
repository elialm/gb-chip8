include "hardware.inc"

; Get adress of cell on virtual screen 0 and load pointer into [hl]
;	x - x coordinate
;	y - y coordinate
LOAD_CELL_SCRN0_HL: macro
	ld hl, _SCRN0 + SCRN_VX_B * \2 + \1
endm

; Wait for V-Blank and then disable the LCD
; Executes halt and waits for V-blank interrupt
LCD_DISABLE_IRQ: macro
	halt
    nop
    ld hl, rLCDC
    res 7, [hl]
endm

; Wait for V-Blank and then disable the LCD
; Loops checking the mode bits in the STAT register
LCD_DISABLE_LOOP: macro
	ld hl, rSTAT
    ld b, $03
    ld c, $01
.loop\@:
    ld a, [hl]
    and a, b
    cp a, c
    jr nz, .loop\@
    ld hl, rLCDC
    res 7, [hl]
endm

; Wait for V-Blank
LCD_AWAIT_VBLANK: macro
	halt
    nop
endm

; Enable the LCD
LCD_ENABLE: macro
	ld hl, rLCDC
    set 7, [hl]
endm

section "Chip8 display routines", rom0

c8_display_init::
    ; Zero screen buffer
    xor a, a
    ld d, a                 ; Copies 256 bytes
    ld hl, c8_screen_buffer
    call memset

    ; Copy sprite data to Chip8 memory
    
    ; Initialise copy loop
    ld e, 16    ; Copy 16 sprites (1 mapped to each nibble value)

    ; Call memcpy to copy one sprite
.sprite_loop:
    ld d, 5
    ld hl, c8_mem           ; Start sprites at Chip8 address $000
    ld bc, c8_char_sprites
    call memcpy

    ; Copy 3 additional padding bytes
    xor a, a
    ld [hl+], a
    ld [hl+], a
    ld [hl+], a

    ; Check loop condition
    dec e
    jr nz, .sprite_loop

    ; Perform Gameboy LCD initialisation

    ; Disable LCD
    LCD_DISABLE_LOOP

    ; Zero tile data
    xor a, a
    ld d, a         ; Clears 16 tiles (16 tiles * 16 = 256 bytes)
    ld hl, _VRAM    ; Points to tile map
    call memset
    ld d, 10 * 16   ; Clears remaining 10 tiles
    call memset

    ; Set tile ID $00 to be a black tile (for screen outline)
    cpl                         ; ~a = $FF
    ld d, 16
    ld hl, _VRAM
    call memset

    ; Initialise window loop for Chip8 display
    ld a, $80               ; Start at tile ID $80
    ld e, 8                 ; Initialise 8 rows
    ld bc, $0010            ; Offset for end of row to start of next
    LOAD_CELL_SCRN0_HL 2,5

    ; Set each tile to incrementing ID numbers
.row_loop:
    ld d, 16                ; Initialise 16 columns
.column_loop:
    ld [hl+], a
    inc a
    dec d
    jr nz, .column_loop
    
    add hl, bc
    dec e
    jr nz, .row_loop

    ; Re-enable the LCD
    LCD_ENABLE

    ret

; Routine will update the Gameboy's display with the internal screen buffer
; Note that this is a routine called by the V-blank IRQ and shall not be called by other code.
c8_display_update::
    ; Push registers to stack
    push af
    push bc
    push de
    push hl

    ; Initialise window loop
    ld a, 8
    ld [c8_dvar_row_counter], a
    ld bc, c8_screen_buffer
    ld hl, $8800            ; Start of tile data

.row_loop:
    ld e, 4     ; Tile counter
.tile_loop:
    ld d, 8     ; Column counter
.column_loop:
    ; Push loop counters on stack to free up registers
    push de
    
    ; Get translated sprite of high nibble
    ld a, [bc]
    swap a
    and a, $0F
    ld de, c8_sprite_translation_table
    add a, e
    ld e, a
    ld a, [de]

    ; Write sprite to VRAM and set hl to point to next 4 pixels
    ld [hl+], a
    inc hl
    ld [hl], a
    ld a, 14
    add a, l
    ld l, a

    ; Get translated sprite of low nibble
    ld a, [bc]
    and a, $0F
    ld de, c8_sprite_translation_table
    add a, e
    ld e, a
    ld a, [de]

    ; Write sprite to VRAM and set hl to point to next 4 pixels
    ld [hl+], a
    inc hl
    ld [hl], a
    ld a, 14
    add a, l
    ld l, a

    ; Update screen buffer pointer
    inc bc

    ; Check column loop progress
    pop de
    dec d
    jr nz, .column_loop

    ; Offset hl to point to next pixel row in tile
    ld a, $04
    add a, l
    ld l, a

    ; Check tile loop progress
    dec e
    jr nz, .tile_loop

    ; Set hl to point to start of next tile row
    xor a, a
    ld l, a
    inc h

    ; Check row loop progress
    ld a, [c8_dvar_row_counter]
    dec a
    ld [c8_dvar_row_counter], a
    jr .row_loop

    ; Pop registers from stack
    pop hl
    pop de
    pop bc
    pop af

    reti

; Character sprites which are copied to Chip8 memory during initialisation.
; Each character is made from 8x5 bytes
c8_char_sprites::
    db $F0,$90,$90,$90,$F0  ; Sprite "0"
    db $20,$60,$20,$20,$70  ; Sprite "1"
    db $F0,$10,$F0,$80,$F0  ; Sprite "2"
    db $F0,$10,$F0,$10,$F0  ; Sprite "3"
    db $90,$90,$F0,$10,$10  ; Sprite "4"
    db $F0,$80,$F0,$10,$F0  ; Sprite "5"
    db $F0,$80,$F0,$90,$F0  ; Sprite "6"
    db $F0,$10,$20,$40,$40  ; Sprite "7"
    db $F0,$90,$F0,$90,$F0  ; Sprite "8"
    db $F0,$90,$F0,$10,$F0  ; Sprite "9"
    db $F0,$90,$F0,$90,$90  ; Sprite "A"
    db $E0,$90,$E0,$90,$E0  ; Sprite "B"
    db $F0,$80,$80,$80,$F0  ; Sprite "C"
    db $E0,$90,$90,$90,$E0  ; Sprite "D"
    db $F0,$80,$F0,$80,$F0  ; Sprite "E"
    db $F0,$80,$F0,$80,$80  ; Sprite "F"

section "Chip8 sprite translation table", rom0, align[$04]

; Table used to translate Chip8 sprites to Gameboy tile data
c8_sprite_translation_table:
    db $00,$03,$0C,$0F
    db $30,$33,$3C,$3F
    db $C0,$C3,$CC,$CF
    db $F0,$F3,$FC,$FF

section "Chip8 display buffer", wram0, align[$08]

; The screen buffer is organised as a 32x8 (HxW) byte matrix
; Each row is 8 bytes (64 bits) long

; Chip8 screen buffer
c8_screen_buffer::
    ds 8 * 32
.end

section "Chip8 display variables", hram

c8_dvar_row_counter:
    ds 1