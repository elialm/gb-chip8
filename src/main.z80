include "hardware.inc"

section "Chip8 Rom", rom0, align[$02]
chip8_rom::
incbin "roms/test_opcode.ch8"

section "Initialisation", rom0[$0150]

; Initialisation
__main::
    di                  ; Disable interrupts
    ld sp, stack_top    ; Initialise stack pointer

; Initialise the emulator
c8_init:
    ; Zero all cpu variables
    ld d, 25
    ld hl, c8_cpu_reg_gp
    xor a, a
    call memset

    ; Initialise program counter
    ld a, $02
    ld [c8_cpu_pc], a

    ; ; Initialise stack pointer
    ; ld a, low(c8_stack)
    ; ld [c8_cpu_sp], a
    ; ld a, high(c8_stack)
    ; ld [c8_cpu_sp+1], a

; Opcode is in bc register
op_run:
    ; Get highest nibble for subdispatcher
    ld a, b
    swap a
    and a, $0F
    
    ; Load subdispatcher number as 16-bit offset
    ld e, a
    xor a, a
    ld d, a

    ; Add this offset thrice to dispatcher table start
    ld hl, subdispatcher_table
    add hl, de
    add hl, de
    add hl, de

    ; Jump to selected subdispatcher
    jp hl

.subdispatcher_ret:
    ret

section "Dispatcher table", rom0
subdispatcher_table:
    jp inst_0xxx_dispatcher
    jp inst_1xxx_dispatcher
    jp inst_2xxx_dispatcher
    jp inst_3xxx_dispatcher
    jp inst_4xxx_dispatcher
    jp inst_5xxx_dispatcher
    jp inst_6xxx_dispatcher
    jp inst_7xxx_dispatcher
    jp inst_8xxx_dispatcher
    jp inst_9xxx_dispatcher
    jp inst_Axxx_dispatcher
    jp inst_Bxxx_dispatcher
    jp inst_Cxxx_dispatcher
    jp inst_Dxxx_dispatcher
    jp inst_Exxx_dispatcher
    jp inst_Fxxx_dispatcher

; 0x0--- dispatcher
;   0x00E0: CLS
;   0x00EE: RET
;   0x0nnn: SYS addr
inst_0xxx_dispatcher:
    ; Ignore instruction if second highest nibble is not 0
    ; This would be the SYS instruction, but this is ignored in modern emulators
    xor a, a
    cp a, b
    jp z, op_run.subdispatcher_ret

    ; Check if CLS instruction
    ld a, $E0
    cp a, c
    jr nz, .check_ret_inst

    ; Perform CLS instruction
    ; TODO - implement CLS

.check_ret_inst:
    ld a, $EE
    cp a, c
    jp nz, inst_fault_handler

    ; Perform RET instruction
    ; TODO - implement RET

    jp op_run.subdispatcher_ret

; 0x1--- dispatcher
;   0x1nnn: JP addr
inst_1xxx_dispatcher:
    jp op_run.subdispatcher_ret

; 0x2--- dispatcher
;   0x2nnn: CALL addr
inst_2xxx_dispatcher:
    jp op_run.subdispatcher_ret

; 0x3--- dispatcher
;   0x3xkk: SE Vx, byte
inst_3xxx_dispatcher:
    jp op_run.subdispatcher_ret

; 0x4--- dispatcher
;   0x4xkk: SNE Vx, byte
inst_4xxx_dispatcher:
    jp op_run.subdispatcher_ret

; 0x5--- dispatcher
;   0x5xy0: SE Vx, Vy
inst_5xxx_dispatcher:
    jp op_run.subdispatcher_ret

; 0x6--- dispatcher
;   0x6xkk: LD Vx, byte
inst_6xxx_dispatcher:
    jp op_run.subdispatcher_ret

; 0x7--- dispatcher
;   0x7xkk: ADD Vx, byte
inst_7xxx_dispatcher:
    jp op_run.subdispatcher_ret

; 0x8--- dispatcher
;   0x8xy0: LD Vx, Vy
;   0x8xy1: OR Vx, Vy
;   0x8xy2: AND Vx, Vy
;   0x8xy3: XOR Vx, Vy
;   0x8xy4: ADD Vx, Vy
;   0x8xy5: SUB Vx, Vy
;   0x8xy6: SHR Vx {, Vy}
;   0x8xy7: SUBN Vx, Vy
;   0x8xyE: SHL Vx {, Vy}
inst_8xxx_dispatcher:
    jp op_run.subdispatcher_ret

; 0x9--- dispatcher
;   0x9xy0: SNE Vx, Vy
inst_9xxx_dispatcher:
    jp op_run.subdispatcher_ret

; 0xA--- dispatcher
;   0xAnnn: LD I, addr
inst_Axxx_dispatcher:
    jp op_run.subdispatcher_ret

; 0xB--- dispatcher
;   0xBnnn: JP V0, addr
inst_Bxxx_dispatcher:
    jp op_run.subdispatcher_ret

; 0xC--- dispatcher
;   0xCxkk: RND Vx, byte
inst_Cxxx_dispatcher:
    jp op_run.subdispatcher_ret

; 0xD--- dispatcher
;   0xDxyn: DRW Vx, Vy, nibble
inst_Dxxx_dispatcher:
    jp op_run.subdispatcher_ret

; 0xE--- dispatcher
;   0xEx9E: SKP Vx
;   0xExA1: SKNP Vx
inst_Exxx_dispatcher:
    jp op_run.subdispatcher_ret

; 0xF--- dispatcher
;   Fx07: LD Vx, DT
;   Fx0A: LD Vx, K
;   Fx15: LD DT, Vx
;   Fx18: LD ST, Vx
;   Fx1E: ADD I, Vx
;   Fx29: LD F, Vx
;   Fx33: LD B, Vx
;   Fx55: LD [I], Vx
;   Fx65: LD Vx, [I]
inst_Fxxx_dispatcher:
    jp op_run.subdispatcher_ret

inst_fault_handler:
end:
    halt

section "Chip8 state", hram

; CPU status

; General purpose registers (16 x 8-bit)
c8_cpu_reg_gp:
    ds 16
; General purpose registers (1 x 16-bit)
c8_cpu_reg_i:
    ds 2
; CPU flag register
c8_cpu_reg_vf:
    ds 1
; Delay timer
c8_cpu_dt:
    ds 1
; Sound timer
c8_cpu_st:
    ds 1
; Program counter
c8_cpu_pc:
    ds 2
; Stack pointer
c8_cpu_sp:
    ds 1

section "Chip8 stack"

c8_stack:
    ds 32